<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis入门</title>
    <url>/posts/52715.html</url>
    <content><![CDATA[<h1 id="Redis简单入门"><a href="#Redis简单入门" class="headerlink" title="Redis简单入门"></a>Redis简单入门</h1><p>Redis是一个开源的，先进的 key-value 存储可用于构建高性能，可扩展的 Web 应用程序的解决方案。</p>
<span id="more"></span>

<p>Redis官方网网站是：<a href="http://www.redis.io/%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://www.redis.io/，如下：</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091054394.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091054394.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209105405266"></p>
<p>Redis 有三个主要使其有别于其它很多竞争对手的特点：</p>
<ul>
<li>Redis是完全在内存中保存数据的数据库，使用磁盘只是为了持久性目的； </li>
<li>Redis相比许多键值数据存储系统有相对丰富的数据类型； </li>
<li>Redis可以将数据复制到任意数量的从服务器中； </li>
</ul>
<h2 id="1-Redis优点"><a href="#1-Redis优点" class="headerlink" title="1.Redis优点"></a>1.Redis优点</h2><ul>
<li><p>异常快速 : Redis是非常快的，每秒可以执行大约110000设置操作，81000个/每秒的读取操作。</p>
</li>
<li><p>支持丰富的数据类型 : Redis支持最大多数开发人员已经知道如列表，集合，可排序集合，哈希等数据类型。</p>
<p>这使得在应用中很容易解决的各种问题，因为我们知道哪些问题处理使用哪种数据类型更好解决。</p>
</li>
<li><p>操作都是原子的 : 所有 Redis 的操作都是原子，从而确保当两个客户同时访问 Redis 服务器得到的是更新后的值（最新值）。</p>
</li>
<li><p>MultiUtility工具：Redis是一个多功能实用工具，可以在很多如：缓存，消息传递队列中使用（Redis原生支持发布/订阅），在应用程序中，如：Web应用程序会话，网站页面点击数等任何短暂的数据；</p>
</li>
</ul>
<h2 id="2-安装和启动redis"><a href="#2-安装和启动redis" class="headerlink" title="2.安装和启动redis"></a>2.安装和启动redis</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>要在windows中安装redis：</p>
<ul>
<li>由于redis官网只提供了linux的下载包，所以我们只能在第三方网站下载</li>
<li>windows版：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></li>
<li>下载完成后解压到一个位置,如：D盘</li>
</ul>
<h3 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h3><p>  执行cmd命令找到redis的存放目录，启动服务器，输入命令 redis-server redis.windows.conf</p>
<p>  运行图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091059384.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091059384.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209105933320"></p>
<p>当然，还有一种通过bat启动的方式</p>
<p>打开redis的根目录，新建一个文本文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091101793.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091101793.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209110110722"></p>
<p>点击打卡文件输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server redis.windows.conf</span><br></pre></td></tr></table></figure>

<p>保存后将文件后缀改为.bat</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091103389.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091103389.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209110315335"></p>
<p>这样就可以直接调用bat文件中的命令来执行</p>
<p>双击redis.bat启动：</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091112167.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091112167.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209111206105"></p>
<ol>
<li>redis版本号</li>
<li>port：端口号</li>
<li>PID：当前redis进程的PID</li>
</ol>
<h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h2><p>运行redis根目录下的redis-cli.exe文件，这是redis下载后自带的客户端工具，它可以用来连接到redis服务器</p>
<p>首先往缓存添加key和value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//set key value </span><br><span class="line">set Name rain</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091138328.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091138328.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209113830284"></p>
<p><font color="red"><strong>注意</strong></font>:在通过客户端存值的时候存入中文将会乱码，但是在实际开发集成到spring开发中，存入的中文会被编码成x*格式，并不会影响中文的正常存取</p>
<p>如果在一个key中存入一个value后再存入一个value那么将替换掉之前的value值</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091141684.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091141684.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209114123644"></p>
<p>从缓存中取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//get key</span><br><span class="line">get Name</span><br></pre></td></tr></table></figure>

<p>从缓存中删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//del key</span><br><span class="line">del Name</span><br></pre></td></tr></table></figure>

<p><font color="green"><strong>补充</strong></font>:</p>
<p>查看所有key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>

<p>删除所有key(清空一个数据库)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flusshdb</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>设置过期时间</strong></font>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//expire keyName seconds(秒)</span><br><span class="line">expire Name 10</span><br></pre></td></tr></table></figure>

<p>对于过期的key，redis不会立即删除</p>
<p>redis有三种清楚策略:</p>
<ul>
<li>被动删除：当读/写一个过期的key时，会触发惰性删除策略，删除这个过期的key</li>
<li>主动删除：因为惰性删除无法保证及时删除，所以redis会定期主动删除一些过期的key</li>
<li>内存:当前已用内存超过maxmemory限定时，触发主动清除策略</li>
</ul>
<p><font color="red"><strong>设置密码</strong></font>:</p>
<p>由于是根据windows.conf启动的redis，所以我们从redis根目录中找到requirepass</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091233399.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091233399.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209123306295"></p>
<p> #是注释内容，下面那行就是我的密码设置，更改后保存</p>
<p><font color="red">！！！根目录下有一个文件叫windows-service.conf，如上图，我们是根据windows.conf启动的redis服务器，因此在这个文件下更改密码无法生效，找到windows.conf下的requirepass foobared在下方更改密码</font></p>
<p>在服务器这里按ctrl+c可以关闭服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091234586.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091234586.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209123431507"></p>
<p>重启服务器打开客户端</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091242440.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091242440.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209124222363"></p>
<p>这个时候存取key值将会报错，我们需要输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//auth password</span><br><span class="line">auth 123</span><br></pre></td></tr></table></figure>

<p>当密码通过验证之后，才可以存取key值</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091243790.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091243790.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20211209124356709"></p>
<p>对于更多redis的命令可以去官网查看</p>
<p>下面是redis的中文官网:</p>
<p><a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>noSql</tag>
      </tags>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/posts/1621.html</url>
    <content><![CDATA[<p>无需多言，反射可以说是学习java的路上必不可少的知识点，同时，说到反射，自然就不可避免的提起注解</p>
<span id="more"></span>

<h1 id="注解（java-Annotation）"><a href="#注解（java-Annotation）" class="headerlink" title="注解（java.Annotation）"></a>注解（java.Annotation）</h1><p>注释 comment</p>
<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><ul>
<li>java5.0开始引入的新技术</li>
<li>Annotation的作用：<ul>
<li>不是程序本身，可以对程序作出解释（这一点而言和注释没有区别）</li>
<li>可以被其他程序（如编译器）读取</li>
<li>有检查和约束的作用</li>
</ul>
</li>
<li>Annotation的格式：<ul>
<li>注解是以”@注释名”在代码中存在的，还可以添加一些参数值，例如@SuppressWarnings(value=”unchecked”)</li>
</ul>
</li>
<li>Annotaion在哪里使用？<ul>
<li>可以附加在package，class，method，filed等上面，相当于增加额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><hr>
<p>  @Override：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法打算重写超类类中另一个方法声明。</p>
<ul>
<li><p>@Deprecated：定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p>
</li>
<li><p>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译好的警告信息</p>
<ul>
<li>与前两个注释不同，它需要一个参数才能正确使用，这些参数都是已经定义好的，直接选择使用即可</li>
<li>@SuppressWarnings(“all”)</li>
<li>@SuppressWarnings(“unchecked”)</li>
<li>@SuppressWarnings(value={“unchecked”,”deprecation”})</li>
</ul>
</li>
</ul>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><hr>
<p>元注解的作用是负责注解其他注解，java定义了四个标准的meta-annotation类型，它们被用来提供对其他annotation类型作说明。</p>
<p>这些类型和它们所支持的类在java.lang.annotation包中可以找到(@Target,@Retention,@Documented,@Inherited)</p>
<ul>
<li><strong>@Target：用于描述注解的使用范围（被描述的注解可以使用在什么地方）</strong></li>
<li><strong>Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期</strong><ul>
<li><strong>(SOURCE(源码)&lt;CLASS(类)&lt;RUNTIME(运行时)</strong>)</li>
</ul>
</li>
<li>@Document：说明该注解被生成在javadoc中</li>
<li>@Inherited:说明子类可以继承父类中的该注解</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><hr>
<p>使用功能@interface自定义注解 时，自动继承了java.lang.annotation.Annotation接口</p>
<ul>
<li>@interface用来声明一个注解，格式：public @interface 注解名{定义内容}</li>
<li>其中声明参数与声明方法类似。</li>
<li>方法的名称就是参数的名称</li>
<li>返回值类型就是参数的类型(返回值只能是基本类型，Class，String，enum)</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0来作为默认值</li>
</ul>
<p>注解的参数：参数类型+参数名();</p>
<p>如果注解定义了参数，注解可以显示赋值，但是如果没有默认值则必须赋值。<img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091402638.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091402638.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20210612152554984"></p>
<h1 id="反射机制-java-Reflection"><a href="#反射机制-java-Reflection" class="headerlink" title="反射机制(java.Reflection)"></a>反射机制(java.Reflection)</h1><blockquote>
<p>静态VS动态语言</p>
</blockquote>
<p><strong>动态语言</strong></p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至    代码可以被引进，已有的函数可以被删除或是其他结构上的变化。简而言之就是代码可以根据某些条件改变自身结构</p>
<p>主要动态语言：Object-C、C#、JavaScript、PHP、Python等</p>
<p><strong>静态语言</strong></p>
<p>与动态语言想对应的，运行时建构不可变的语言就是静态语言。如java、C、C++</p>
<p>Java不是动态语言，但Java可以称之为”准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活</p>
<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><hr>
<p><strong>Reflection(反射)是Java被视为动态语言的关键，反射机制允许任何程序在执行期借助于ReflectionAPI取得任何类的内部信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(&quot;java.lang.String&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</strong></p>
<p>正常方式：引入需要的“包类名称”→通过new实例化→取得实例化对象</p>
<p>反射方式：实例化对象→getClass()方法→得到完整的“包类”名称</p>
<h2 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h2><p>1.在运行时判断任意一个对象所属的类</p>
<p>2.在运行时构造任意一个类的对象</p>
<p>3.在运行时判断任意一个类所具有的成员变量和方法</p>
<p>4.在运行时获取泛型信息</p>
<p>5.在运行时调用任意一个对象的成员变量和方法</p>
<p>6.在运行时处理注解</p>
<p>7.生成动态代理</p>
<h3 id="反射的优点"><a href="#反射的优点" class="headerlink" title="反射的优点"></a><strong>反射的优点</strong></h3><p>可以实现动态创建对象和编译，体现出很大的灵活性</p>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><p>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作</p>
<h3 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h3><ul>
<li>java.lang.Class代表一个类</li>
<li>java.lang.reflect.Method代表类的方法</li>
<li>java.lang.reflect.Field代表类的成员变量</li>
<li>java.lang.reflect.Constructor代表类的构造器</li>
</ul>
<blockquote>
<p>注：一个类在内存中只有一个Class对象</p>
<p>一个类被加载后，类的整个结构都会被封装在Class对象中</p>
</blockquote>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。<br>对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/]）的有关信息。</p>
<ul>
<li>Class对象只能由系统建立对象</li>
<li>一个加载的类在JVM中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个cless文件</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运的类，唯有先获得相应的Class对象</li>
</ul>
<h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName(String name)</td>
<td>返回指定类名name的Class对象</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>调用缺省构造函数，返回Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体(类，接口，数组类，或void)的名称</td>
</tr>
<tr>
<td>Class getSuperClass()</td>
<td>返回当前class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>获取该类的类加载器</td>
</tr>
<tr>
<td>Constructor[] getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="class类的创建方式"><a href="#class类的创建方式" class="headerlink" title="class类的创建方式"></a>class类的创建方式</h3><p>hashCode()字符串的哈希值</p>
<p>方式一：通过对象获取</p>
<p>Class c1 = person.getClass();</p>
<p>方式二：forname获得</p>
<p>Class c2 = Class.forName(“包名”);</p>
<p>方式三：通过类名.class获得</p>
<p>Class c3 =Student.class;</p>
<p>方法四：内置基本数据类型可以直接用类名.Type</p>
<p>Class c4=Integer.TYPE;</p>
<p>方法五:通过子类获取父类</p>
<p>Class c5=c1.getsuperclass();</p>
<h3 id="哪些类型可以有Class对象（万物皆对象）"><a href="#哪些类型可以有Class对象（万物皆对象）" class="headerlink" title="哪些类型可以有Class对象（万物皆对象）"></a>哪些类型可以有Class对象（万物皆对象）</h3><p>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</p>
<p>interface：接口</p>
<p>[]：数组</p>
<p>enum：枚举</p>
<p>annotation：注解@interface</p>
<p>primitive type：基本数据类型</p>
<p>void</p>
<p>底层class相同则对象依旧是同一个</p>
<h2 id="java内存分析"><a href="#java内存分析" class="headerlink" title="java内存分析"></a>java内存分析</h2><p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091403883.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091403883.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20210615163740464"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><blockquote>
<p>当程序主动使用功能某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091403767.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091403767.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20210615164414400"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            A a=<span class="keyword">new</span> A();</span><br><span class="line">            System.out.println(A.m);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              1.加载到内存，会产生一个对应的class对象</span></span><br><span class="line"><span class="comment">              2.链接，链接结束后m=0；</span></span><br><span class="line"><span class="comment">              3.初始化</span></span><br><span class="line"><span class="comment">                &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;A静态代码初始化&quot;);</span></span><br><span class="line"><span class="comment">                    m=300;</span></span><br><span class="line"><span class="comment">                    m=200;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码块加载！&quot;</span>);</span><br><span class="line">        m=<span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类无参构造初始化!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候会发生类初始化"><a href="#什么时候会发生类初始化" class="headerlink" title="什么时候会发生类初始化"></a>什么时候会发生类初始化</h3><blockquote>
<p>类的主动引用(一定会发生类的初始化)</p>
</blockquote>
<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员(除了final常量)和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用（反射也会产生主动引用）</li>
<li>当初始化一个类，如果父类没有被初始化，则先初始化父类</li>
</ul>
<blockquote>
<p>类的被动引用(不会发生类的初始化)</p>
</blockquote>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：使用子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中)</li>
</ul>
<h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><p>java核心jar包：rt.jar</p>
<blockquote>
<p>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
</blockquote>
<blockquote>
<p>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091404899.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112091404899.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20210615204000980"></p>
<p>类的加载器作用是用来把类(class)装载进内存的。JVM规范定义了如下类型的类加载器。</p>
<p>引导类加载器：用C++编写的，是JVM自带的类加载器，负责java平台核心库，用来装载核心类库。<strong>该加载器无法直接获取</strong>（扩展类加载器的父类加载器：根加载器）</p>
<p>扩展类加载器：负责jre/lib/ext目录下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库（系统加载器的父类加载器）</p>
<p>系统类加载器：负责java -classpath或-D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器（用户加载类）</p>
<h4 id="如何获取系统类加载器可以加载的路径"><a href="#如何获取系统类加载器可以加载的路径" class="headerlink" title="如何获取系统类加载器可以加载的路径"></a>如何获取系统类加载器可以加载的路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(“java.class.path”);</span><br></pre></td></tr></table></figure>

<h3 id="通过反射获取运行时类的完整结构"><a href="#通过反射获取运行时类的完整结构" class="headerlink" title="通过反射获取运行时类的完整结构"></a>通过反射获取运行时类的完整结构</h3><p>Filed、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
<li>注解</li>
<li>。。。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Class c=Class.forName(<span class="string">&quot;com.example.classLoad.User&quot;</span>);</span><br><span class="line"><span class="comment">//        User user=new User();</span></span><br><span class="line">  <span class="comment">// Class&lt;? extends User&gt;aClass=user.getClass();</span></span><br><span class="line">        <span class="comment">//c=user.getClass();</span></span><br><span class="line">        <span class="comment">//获取类的包名</span></span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">        <span class="comment">//获取类的父类</span></span><br><span class="line">        System.out.println(c.getSuperclass());</span><br><span class="line">        <span class="comment">//获取类名</span></span><br><span class="line">        System.out.println(c.getSimpleName());</span><br><span class="line">        <span class="comment">//获取类的接口</span></span><br><span class="line">        System.out.println(c.getInterfaces());</span><br><span class="line">        <span class="comment">//获取所有属性 public 级别</span></span><br><span class="line">        Field[] fields=c.getFields();</span><br><span class="line">        <span class="comment">//获取所有属性 所有级别</span></span><br><span class="line">        fields=c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定属性</span></span><br><span class="line">        Field field=c.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        <span class="comment">//获得所有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有方法:\n&quot;</span>);</span><br><span class="line">        <span class="comment">//获得本类及其父类的全部public方法</span></span><br><span class="line">        Method[] methods=c.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正常获取:&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类的所有方法</span></span><br><span class="line">        methods=c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;getDeclaredMethods：&quot;</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定方法</span></span><br><span class="line">        Method method=c.getMethod(<span class="string">&quot;setUserName&quot;</span>, String.class);</span><br><span class="line">        Method method1=c.getMethod(<span class="string">&quot;getUserName&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取指定方法:&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(method1);</span><br><span class="line">        <span class="comment">//获得所有构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获得的构造器&quot;</span>);</span><br><span class="line">        Constructor[] constructors=c.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定的构造器</span></span><br><span class="line">        Constructor constructor1=c.getConstructor(String.class,String.class);</span><br><span class="line">        System.out.println(constructor1);</span><br></pre></td></tr></table></figure>

<h2 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h2><blockquote>
<p>Class可以做什么？</p>
</blockquote>
<p>创建类的对象：调用Class对象的newInstance()方法</p>
<ol>
<li>类必须有一个无参构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ol>
<p><strong>问：如果没有无参构造器就不能创建对象吗？在操作的时候明确的调用类中的构造器，并将参数传递进去，就可以进行实例化操作</strong></p>
<p>步骤如下：</p>
<ol>
<li>通过Class类的getDeclaredConstructor(Class …ParamterTypes)取得本类中指定的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数</li>
<li>通过Constructor实例化对象</li>
</ol>
<h3 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h3><blockquote>
<p>通过反射，调用类中的方法，通过Method类完成</p>
</blockquote>
<ol>
<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型</li>
<li>之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112081152568.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112081152568.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="image-20210618020626859"></p>
<ol>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法若为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li>
</ol>
<h4 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h4><ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class c=Class.forName(<span class="string">&quot;com.example.classLoad.User&quot;</span>);</span><br><span class="line"><span class="comment">//构造一个对象</span></span><br><span class="line">User user =(User) c.newInstance();</span><br><span class="line"><span class="comment">//System.out.println(user);</span></span><br><span class="line"><span class="comment">/*通过构造器创建对象*/</span></span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">Constructor constructor=c.getDeclaredConstructor(String.class,String.class);</span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line">Object user1 = constructor.newInstance(<span class="string">&quot;洛琊&quot;</span>,<span class="string">&quot;0319&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(user1);</span></span><br><span class="line"><span class="comment">/*通过反射调用方法*/</span></span><br><span class="line"><span class="comment">//获取方法</span></span><br><span class="line">Method method=c.getDeclaredMethod(<span class="string">&quot;setUserName&quot;</span>, String.class);</span><br><span class="line"><span class="comment">//运行方法 invoke:激活</span></span><br><span class="line"><span class="comment">//第一个参数：对象 第二个参数：方法的参数</span></span><br><span class="line">method.invoke(user,<span class="string">&quot;洛琊&quot;</span>);</span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="comment">//System.out.println(user.getUserName());</span></span><br><span class="line"><span class="comment">/*通过反射操作对象的属性*/</span></span><br><span class="line">Field userName = c.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="comment">//不能直接操作私有属性，需要关闭程序的安全检测，属性或者方法的setAccessible(true)</span></span><br><span class="line">userName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">userName.set(user,<span class="string">&quot;洛琊&quot;</span>);</span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line"><span class="comment">//System.out.println(user.getUserName());</span></span><br></pre></td></tr></table></figure>

<h3 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h3><blockquote>
<p>Java采用泛型擦除的机制来引入泛型,Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性和免去强制类型转换问题﹐但是，一旦编译完成,所有和泛型有关的类型全部擦除</p>
</blockquote>
<blockquote>
<p>为了通过反射操作这些类型，Java新增了ParameterizedType , GenericArrayType ,TypeVariable和 WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型.</p>
</blockquote>
<ul>
<li>ParameterizedType:表示一种参数化类型,比如Collection<String></String></li>
<li>GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型</li>
<li>TypeVariable:是各种类型变量的公共父接口</li>
<li>WildcardType:代表一种通配符类型表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method = Test01.class.getMethod(<span class="string">&quot;test01&quot;</span>, Map.class, List.class);</span><br><span class="line"><span class="comment">//获得泛型的参数信息</span></span><br><span class="line">Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">    <span class="comment">//System.out.println(genericParameterType);</span></span><br><span class="line">    <span class="comment">//泛型的参数类型是否等于结构化的参数类型</span></span><br><span class="line">    <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">        <span class="comment">//获得真实的泛型参数类型</span></span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">            System.out.println(actualTypeArgument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Method method1 = Test01.class.getMethod(<span class="string">&quot;test02&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">Type genericReturnType = method1.getGenericReturnType();</span><br><span class="line"><span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">    Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">        System.out.println(actualTypeArgument);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h2><blockquote>
<p>什么是ORM</p>
</blockquote>
<p>ORM 对象关系映射(Object relationship Mapping)</p>
<ul>
<li>类和表结构对应</li>
<li>属性和字段对应</li>
<li>对象和记录对应</li>
</ul>
<h3 id="利用注解和反射完成类和表结构的映射关系"><a href="#利用注解和反射完成类和表结构的映射关系" class="headerlink" title="利用注解和反射完成类和表结构的映射关系"></a>利用注解和反射完成类和表结构的映射关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得class类</span></span><br><span class="line">Class cTudent=Class.forName(<span class="string">&quot;cn.com.test.Student&quot;</span>);</span><br><span class="line"><span class="comment">//获得类所有注解</span></span><br><span class="line">Annotation[] declaredAnnotations = cTudent.getDeclaredAnnotations();</span><br><span class="line"><span class="comment">//获得指定注解</span></span><br><span class="line">Annotation annotation=(dbName)cTudent.getDeclaredAnnotation(dbName.class);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>面向底层</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程</title>
    <url>/posts/9650.html</url>
    <content><![CDATA[<p>作为一个程序员，学习计算机网络知识可以说是必不可少的，本篇是我在学习java网络编程过程中的笔记，作为此博客的第一篇文章</p>
<span id="more"></span>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><blockquote>
<h2 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h2></blockquote>
<p>计算机网络是指将<a href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86">地理</a>位置不同的具有独立功能的多台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>及其外部设备，通过通信线路连接起来，在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997">网络操作系统</a>，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078">网络管理软件</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611">网络通信协议</a>的管理和协调下，实现<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480">资源共享</a>和信息传递的计算机系统</p>
<p><strong>网络编程的目的</strong></p>
<p>​            无线电台…传播交流信息，数据交换，通信。</p>
<p><strong>想达到这个效果需要什么</strong>？</p>
<ol>
<li>如何准确的定位网络上的一台主机 IP:端口,定位到这个计算机上的某个资源</li>
<li>找到主机后如何传输资源</li>
</ol>
<p>Javaweb：网页编程 B/S架构</p>
<p>网络编程：TCP/IP  C/S架构</p>
<h2 id="2-网络通信的要素"><a href="#2-网络通信的要素" class="headerlink" title="2.网络通信的要素"></a>2.网络通信的要素</h2><p>如何实现网络通信？</p>
<p><strong>通信双方地址</strong></p>
<p><strong>规则：网络通<img src="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112081153336.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/oyjc13/pic@main/img/202112081153336.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="网络协议">信的协议</strong> udp，tcp<br><img src="/posts/9650.htm/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png" class="lazyload placeholder" data-srcset="/posts/9650.htm/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="网络协议"></p>
<h2 id="3-IP"><a href="#3-IP" class="headerlink" title="3.IP"></a>3.IP</h2><p>IP地址:InetAddress </p>
<ul>
<li><p>唯一定位一台网络上计算机</p>
</li>
<li><p>127.0.0.1：本机localhost </p>
</li>
<li><p>ip地址的分类</p>
<ul>
<li><p>IPV4/IPv6</p>
<ul>
<li>IPv4 127.0.0.1,4个字节组成。0~255,42亿2011用尽了</li>
<li>IPv6  fe80::8f6:d5df:50e3:5a5d%18</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2001:0bb2:aaaa:0015:0000:0000:1bbb:1121</span><br></pre></td></tr></table></figure>

<p>​            128位。8个无符号整数！</p>
</li>
<li><p>公网(互联网)-私网(局域网)</p>
<ul>
<li>ABCD类IP地址</li>
<li>192.168.xx.xx，专门给组织内部用的</li>
</ul>
</li>
<li><p>域名:记忆IP问题！</p>
<ul>
<li>IP:<a href="http://www.vip.com/">www.vip.com</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询Ip地址</span></span><br><span class="line">InetAddress inetAddress1 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-端口"><a href="#4-端口" class="headerlink" title="4.端口"></a>4.端口</h2><p>端口表示计算机上的一个程序的进程;</p>
<ul>
<li><p>不同的进程有不同的端口号，用来区分软件</p>
</li>
<li><p>被规定0~65535</p>
</li>
<li><p>TCP，UDP</p>
</li>
<li><p>端口分类</p>
<ul>
<li><p>共有端口 0~1023</p>
<ul>
<li>HTTP:80</li>
<li>HTTPS:443</li>
<li>FTP:21</li>
<li>Telent:23</li>
</ul>
</li>
<li><p>程序注册端口:1024~49151，分配给用户或程序</p>
<ul>
<li>Tomcat 8080</li>
<li>MySql 3306</li>
<li>Oravle 1521</li>
</ul>
</li>
<li><p>动态、私有端口:49152~65535</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano <span class="comment">#查看所有的端口</span></span><br><span class="line">netstat -ano findstr <span class="string">&quot;端口号&quot;</span><span class="comment">#查看指定端口</span></span><br><span class="line">tasklist|findstr <span class="string">&quot;端口号&quot;</span><span class="comment">#查看指定端口的进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-通信协议"><a href="#5-通信协议" class="headerlink" title="5.通信协议"></a>5.通信协议</h2><p><strong>网络通信协议：</strong>速率，传输码率，代码结构，传输控制</p>
<p>大事化小：分层</p>
<p><strong>TCP/IP协议簇</strong>:实际上是一组协议</p>
<p>重要：</p>
<ul>
<li>TCP:用户传输协议</li>
<li>UDP:用户数据报协议</li>
<li>IP:网络互连协议</li>
</ul>
<p>TCP UDP 对比</p>
<p>TCP:打电话</p>
<ul>
<li>连接，稳定</li>
<li>三次握手 四次挥手</li>
<li>客户端   服务端</li>
<li>传输完成，释放连接，效率低</li>
</ul>
<p>UDP:发短信</p>
<ul>
<li>不连接，不稳定</li>
<li>客户端、服务端:没有明确的界限</li>
<li>不管有没有准备好，都可以发给你</li>
<li>DDOS</li>
</ul>
<h2 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h2><p>客户端</p>
<ol>
<li>连接服务器Socket</li>
<li>发送消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress serverIP = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.要知道服务器的地址，端口号</span></span><br><span class="line">                serverIP = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">                <span class="comment">//2.创建一个socket连接</span></span><br><span class="line">                socket = <span class="keyword">new</span> Socket(serverIP, port);</span><br><span class="line">                <span class="comment">//发送消息，使用IO流</span></span><br><span class="line">                os = socket.getOutputStream();</span><br><span class="line">                os.write(<span class="string">&quot;你好，欢迎学习狂神说java&quot;</span>.getBytes());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        os.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>服务器</p>
<ol>
<li>建立服务的端口  ServerSocket</li>
<li>等待用户的链接 accept</li>
<li>接收用户的消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.我要有一个地址</span></span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">                <span class="comment">//2.等待客户连接过来</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//3.读取客户端发送来的信息</span></span><br><span class="line">                is = socket.getInputStream();</span><br><span class="line">                <span class="comment">//使用管道流</span></span><br><span class="line">                baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(baos.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        serverSocket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        baos.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h2><p>发短信：不用连接，需要知道对方的地址</p>
<hr>
<blockquote>
<p>发送端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.建立一个socket</span></span><br><span class="line">       DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line">       <span class="comment">//2.建包</span></span><br><span class="line">       String msg=<span class="string">&quot;Hello World！&quot;</span>;</span><br><span class="line">       InetAddress localhost=InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> port=<span class="number">9090</span>;</span><br><span class="line">       <span class="comment">//数据，数据的长度起始，要发送给谁</span></span><br><span class="line">       DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(),<span class="number">0</span>,msg.getBytes().length,localhost,port);</span><br><span class="line">       <span class="comment">//3.发送包</span></span><br><span class="line">       socket.send(packet);</span><br><span class="line">       <span class="comment">//4.关闭流</span></span><br><span class="line">       socket.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接收端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开放端口</span></span><br><span class="line">       DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line">       <span class="comment">//接收数据包</span></span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">       socket.receive(packet);<span class="comment">//阻塞接收</span></span><br><span class="line">       <span class="comment">//关闭连接</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(packet.getData(), <span class="number">0</span>, packet.getLength()));</span><br></pre></td></tr></table></figure>

<p>8.URL</p>
<p><a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<p>统一资源定位符:定位资源的，定义互联网上的某一个资源</p>
<p>DNS域名解析 <a href="http://www.baidu.com/">www.baidu.com</a> xx.xx.xx.xx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协议：//ip地址：端口/项目名/资源</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.下载地址</span></span><br><span class="line">     URL url =<span class="keyword">new</span> URL(<span class="string">&quot;https://m801.music.126.net/20210713173846/7dc4ee6b99a88d6c6b455d11d14a350f/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/7937683494/31e2/2771/3eef/e1a6f0f79db893a61118d620b204384f.m4a&quot;</span>);</span><br><span class="line">     <span class="comment">//连接到这个资源 HTTP</span></span><br><span class="line">     HttpURLConnection urlConnection=(HttpURLConnection) url.openConnection();</span><br><span class="line">     InputStream inputStream=urlConnection.getInputStream();</span><br><span class="line">     FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;还是会想你.m4a&quot;</span>);</span><br><span class="line">     <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">     <span class="keyword">int</span> len;</span><br><span class="line">     <span class="keyword">while</span> ((len=inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">         fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">     &#125;</span><br><span class="line">     fos.close();</span><br><span class="line">     inputStream.close();</span><br><span class="line">     urlConnection.disconnect();<span class="comment">//断开连接</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
